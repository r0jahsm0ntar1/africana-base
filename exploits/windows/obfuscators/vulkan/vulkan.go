package main

import (
    "fmt"
    "math/rand"
    "os"
    "regexp"
    "sort"
    "strconv"
    "strings"
    "time"
    "unicode"
)

// Global variables
var obfuscatedStrings []string
var knownCmdlets = []string{
    "Add-Computer", "Add-Content", "Add-EtwTraceProvider", "Add-History", "Add-JobTrigger",
    // ... (all the other cmdlets from your original list)
    "IEX",
}

var specialVars = []string{
    "$true", "$false", "$null", "$env", "$read", "$error", "$verb", "$_", "$script",
    // ... (all the other special variables from your original list)
}

var knownNamespaceClasses = []string{
    "io.streamwriter", "system.net.sockets.tcpclient", "net.sockets.tcpclient",
    // ... (all the other namespace classes from your original list)
}

var noBackticks = "0abefnrtuxv"
var specialCharacters = "?<>',?[]}{=-)(*&^%$#`~{}"

var safeMode bool
var allMode bool
var verboseMode bool
var caseObfs bool

// Helper functions

func generateRandomString(length int) string {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    if length < 5 {
        length = 5
    }

    var result string
    for {
        // Randomize length slightly
        mod := rand.Intn(3)
        actualLength := length
        switch mod {
        case 0:
            actualLength = length - 1
        case 1:
            actualLength = length + 1
        }

        b := make([]byte, actualLength)
        for i := range b {
            b[i] = charset[rand.Intn(len(charset))]
        }
        result = string(b)

        // Check if string is unique
        unique := true
        for _, s := range obfuscatedStrings {
            if s == result {
                unique = false
                break
            }
        }

        if unique {
            obfuscatedStrings = append(obfuscatedStrings, result)
            break
        }
    }
    return result
}

func obfuscateWordCase(str string) string {
    var result strings.Builder
    for _, c := range str {
        if rand.Intn(2) == 0 {
            result.WriteRune(unicode.ToLower(c))
        } else {
            result.WriteRune(unicode.ToUpper(c))
        }
    }
    return result.String()
}

func addBackticksToWord(str string) string {
    var result strings.Builder
    for _, c := range str {
        char := string(c)
        if strings.Contains(specialCharacters, char) {
            result.WriteString(char)
            continue
        }

        if strings.Contains(noBackticks, strings.ToLower(char)) {
            result.WriteString(char)
            continue
        }

        if rand.Intn(3) != 0 { // 66% chance
            result.WriteString("`" + char)
        } else {
            result.WriteString(char)
        }
    }
    return result.String()
}

// Obfuscation functions

func obfuscateVariables(data string) string {
    if verboseMode {
        fmt.Println("[*] Obfuscating variables...")
    }

    re := regexp.MustCompile(`\$[\w|_]+`)
    matches := re.FindAllString(data, -1)

    uniqueVars := make(map[string]bool)
    for _, match := range matches {
        uniqueVars[match] = true
    }

    for varName := range uniqueVars {
        lowerVar := strings.ToLower(varName)
        isSpecial := false
        for _, special := range specialVars {
            if strings.ToLower(special) == lowerVar {
                isSpecial = true
                break
            }
        }

        if !isSpecial {
            newVar := "$" + generateRandomString(10)
            data = strings.ReplaceAll(data, varName, newVar)
        }
    }

    return data
}

func obfuscateFunctions(data string) string {
    if verboseMode {
        fmt.Println("[*] Obfuscating functions...")
    }

    re := regexp.MustCompile(`function\s+([\w|\_|\-]+)\s*\{`)
    matches := re.FindAllStringSubmatch(data, -1)

    var functions []string
    for _, match := range matches {
        if len(match) > 1 {
            functions = append(functions, match[1])
        }
    }

    // Sort by descending length
    sort.Slice(functions, func(i, j int) bool {
        return len(functions[i]) > len(functions[j])
    })

    for _, funcName := range functions {
        if len(funcName) > 5 {
            newFunc := generateRandomString(12)

            if strings.Contains(funcName, ":") {
                parts := strings.Split(funcName, ":")
                data = strings.ReplaceAll(data, "function "+parts[0]+":"+parts[1], "function "+parts[0]+":"+newFunc)
            } else {
                data = strings.ReplaceAll(data, "function "+funcName, "function "+newFunc)
            }

            // Replace all occurrences of the function name
            data = strings.ReplaceAll(data, funcName, newFunc)
        }
    }

    return data
}

func obfuscateCmdlets(data string) string {
    if verboseMode {
        fmt.Println("[*] Obfuscating cmdlets...")
    }

    for _, cmdlet := range knownCmdlets {
        if strings.Contains(strings.ToLower(data), strings.ToLower(cmdlet)) {
            cmdletRandNum := rand.Intn(3) + 1
            var modedStr string

            switch cmdletRandNum {
            case 1:
                if caseObfs {
                    modedStr = addBackticksToWord(obfuscateWordCase(cmdlet))
                } else {
                    modedStr = addBackticksToWord(cmdlet)
                }
            case 2:
                modedStr = "&([string]::join('', ( ("
                for _, b := range []byte(cmdlet) {
                    modedStr += strconv.Itoa(int(b)) + ","
                }
                modedStr = strings.TrimSuffix(modedStr, ",")
                if caseObfs {
                    modedStr += ") |%{ ( [" + obfuscateWordCase("char") + "][" + obfuscateWordCase("int") + "] $_)})))"
                } else {
                    modedStr += ") |%{ ( [char][int] $_)})))"
                }
            case 3:
                rawStr := ""
                modedStr = "&((\""

                for _, char := range cmdlet {
                    randNum := rand.Intn(4) + 1
                    randStr := generateRandomString(randNum)

                    if rand.Intn(2) == 0 {
                        modedStr += string(char) + randStr
                        rawStr += string(char) + randStr
                    } else {
                        modedStr += randStr + string(char)
                        rawStr += randStr + string(char)
                    }
                }
                modedStr += "\")["

                for _, char := range cmdlet {
                    modedStr += strconv.Itoa(strings.Index(rawStr, string(char))) + ","
                }
                modedStr = strings.TrimSuffix(modedStr, ",")
                modedStr += "] -join '')"
            }

            // Case-insensitive replacement
            re := regexp.MustCompile("(?i)" + regexp.QuoteMeta(cmdlet))
            data = re.ReplaceAllString(data, modedStr)
        }
    }

    return data
}

func obfuscateNamespaces(data string) string {
    if verboseMode {
        fmt.Println("[*] Obfuscating namespace classes...")
    }

    // Sort by descending length
    sort.Slice(knownNamespaceClasses, func(i, j int) bool {
        return len(knownNamespaceClasses[i]) > len(knownNamespaceClasses[j])
    })

    for _, namespace := range knownNamespaceClasses {
        if strings.Contains(strings.ToLower(data), strings.ToLower(namespace)) {
            modedStr := "$("
            for _, char := range namespace {
                randNum := rand.Intn(100) + 1
                randType := rand.Intn(7) + 1

                if caseObfs {
                    modedStr += "[" + obfuscateWordCase("char") + "]"
                } else {
                    modedStr += "[char]"
                }

                switch randType {
                case 1:
                    modedStr += fmt.Sprintf("(%d+%d-%d)+", randNum, char, randNum)
                case 2:
                    modedStr += fmt.Sprintf("(%d*%d/%d)+", randNum, char, randNum)
                case 3:
                    modedStr += fmt.Sprintf("(%d*%d/%d)+", char, randNum, randNum)
                case 4:
                    modedStr += fmt.Sprintf("(0+%d+0)+", char)
                case 5:
                    modedStr += fmt.Sprintf("(0+%d-0)+", char)
                case 6:
                    modedStr += fmt.Sprintf("(%d+%d-%d)+", char, randNum, randNum)
                case 7:
                    modedStr += fmt.Sprintf("(%d-%d+%d)+", char, randNum, randNum)
                }
            }
            modedStr = strings.TrimSuffix(modedStr, "+")
            modedStr += ")"

            re := regexp.MustCompile("(?i)" + regexp.QuoteMeta(namespace))
            data = re.ReplaceAllString(data, modedStr)
        }
    }

    return data
}

func obfuscateBackticks(data string) string {
    if verboseMode {
        fmt.Println("[*] Adding backticks...")
    }

    re := regexp.MustCompile(`function\s+([\w|\_|\-]+)\s*\{`)
    matches := re.FindAllStringSubmatch(data, -1)

    var functions []string
    for _, match := range matches {
        if len(match) > 1 {
            functions = append(functions, match[1])
        }
    }

    // Sort by descending length
    sort.Slice(functions, func(i, j int) bool {
        return len(functions[i]) > len(functions[j])
    })

    for _, funcName := range functions {
        if strings.Contains(funcName, ":") {
            funcName = strings.Split(funcName, ":")[1]
        }

        var newName string
        if caseObfs {
            newName = addBackticksToWord(obfuscateWordCase(funcName))
        } else {
            newName = addBackticksToWord(funcName)
        }

        re := regexp.MustCompile("(?i)" + regexp.QuoteMeta(funcName))
        data = re.ReplaceAllString(data, newName)
    }

    return data
}

func obfuscatePipes(data string) string {
    if verboseMode {
        fmt.Println("[*] Obfuscating pipes...")
    }

    lines := strings.Split(data, "\n")
    for i, line := range lines {
        if strings.Contains(line, "|") {
            pipeRandNum := rand.Intn(7) + 1
            var modedLine string

            switch pipeRandNum {
            case 1:
                modedLine = strings.ReplaceAll(line, "|", "|%{$_}|")
            case 2:
                modedLine = strings.ReplaceAll(line, "|", "|<##>%{$_}|")
            case 3:
                modedLine = strings.ReplaceAll(line, "|", "|%{$_}<##>|")
            case 4:
                modedLine = strings.ReplaceAll(line, "|", "|<##>%{$_}<##>|")
            case 5:
                modedLine = strings.ReplaceAll(line, "|", "|%{;$_}|")
            case 6:
                modedLine = strings.ReplaceAll(line, "|", "|%{$_;}|")
            case 7:
                modedLine = strings.ReplaceAll(line, "|", "|%{;$_;}|")
            }

            lines[i] = modedLine
        }
    }

    return strings.Join(lines, "\n")
}

func obfuscateComments(data string) string {
    if verboseMode {
        fmt.Println("[*] Removing multi-line comments...")
        fmt.Println("[*] Removing single-line comments...")
    }

    // Remove multi-line comments
    re := regexp.MustCompile(`<#.*?#>`)
    data = re.ReplaceAllString(data, "")

    // Remove single-line comments
    re = regexp.MustCompile(`^\s*#.*$`)
    lines := strings.Split(data, "\n")
    for i, line := range lines {
        lines[i] = re.ReplaceAllString(line, "")
    }
    data = strings.Join(lines, "\n")

    // Remove empty lines
    re = regexp.MustCompile(`(?m)^\s*$[\r\n]*|[\r\n]+\s+\z`)
    data = re.ReplaceAllString(data, "")

    return data
}

func obfuscateIndentation(data string) string {
    if verboseMode {
        fmt.Println("[*] Obfuscating indentation...")
    }

    lines := strings.Split(data, "\n")
    for i, line := range lines {
        indentationRandNum := rand.Intn(7) + 1
        if indentationRandNum == 1 || indentationRandNum == 2 {
            tabsToAdd := rand.Intn(3) + 1
            totalTabs := strings.Repeat("  ", tabsToAdd)
            lines[i] = totalTabs + line
        }
    }

    return strings.Join(lines, "\n")
}

func obfuscateIPs(data string) string {
    if verboseMode {
        fmt.Println("[*] Converting IP addresses to hex...")
    }

    ipRegex := regexp.MustCompile(`(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])`)
    matches := ipRegex.FindAllString(data, -1)

    for _, ip := range matches {
        octets := strings.Split(ip, ".")
        var hexOctets []string
        for _, octet := range octets {
            num, _ := strconv.Atoi(octet)
            hexOctets = append(hexOctets, fmt.Sprintf("%02X", num))
        }
        hexIP := "0x" + strings.Join(hexOctets, "")
        data = strings.ReplaceAll(data, ip, hexIP)
    }

    return data
}

func obfuscateSpecialVars(data string) string {
    if verboseMode {
        fmt.Println("[*] Obfuscating special variables...")
    }

    specialVarsToObfuscate := []string{"$true", "$false", "$null"}
    for _, varName := range specialVarsToObfuscate {
        if strings.Contains(data, varName) {
            randNum := rand.Intn(2) + 1
            if randNum == 1 {
                data = strings.ReplaceAll(data, varName, obfuscateWordCase(varName))
            } else {
                newVar := "$" + generateRandomString(10)
                data = strings.ReplaceAll(data, varName, newVar)
                if caseObfs {
                    data = fmt.Sprintf("%s = %s\n%s", newVar, obfuscateWordCase(varName), data)
                } else {
                    data = fmt.Sprintf("%s = %s\n%s", newVar, varName, data)
                }
            }
        }
    }

    return data
}

func obfuscateAll(data string) string {
    data = obfuscateComments(data)
    data = obfuscateVariables(data)
    data = obfuscateFunctions(data)
    data = obfuscateCmdlets(data)
    data = obfuscateNamespaces(data)
    data = obfuscateBackticks(data)
    data = obfuscatePipes(data)
    data = obfuscateIndentation(data)
    data = obfuscateIPs(data)
    return data
}

func obfuscateSafe(data string) string {
    data = obfuscateComments(data)
    data = obfuscateVariables(data)
    data = obfuscateFunctions(data)
    data = obfuscateCmdlets(data)
    data = obfuscateNamespaces(data)
    data = obfuscateBackticks(data)
    data = obfuscatePipes(data)
    return data
}

func printASCII() {
    banner := `
╦  ╦┬ ┬┬  ┬┌─┌─┐┌┐┌
╚╗╔╝│ ││  ├┴┐├─┤│││
 ╚╝ └─┘┴─┘┴ ┴┴ ┴┘└┘
    by D3Ext v0.2
`
    fmt.Println("\033[31m" + banner + "\033[0m")
}

func showHelpPanel() {
    fmt.Println("Usage of Vulkan:")
    fmt.Println("  REQUIRED ARGUMENTS:")
    fmt.Println("    -f, --file string     source Powershell script to obfuscate")
    fmt.Println("    -o, --output string   store obfuscated script in a file")
    fmt.Println()
    fmt.Println("  OPTIONAL ARGUMENTS:")
    fmt.Println("    -a, --all       use all obfuscation techniques")
    fmt.Println("    -s, --safe      enable safe obfuscation mode to prevent the script from breaking (use almost all obfuscation techniques) (enabled by default)")
    fmt.Println("    --vars          enable variable obfuscation")
    fmt.Println("    --funcs         enable functions obfuscation")
    fmt.Println("    --cmdlets       enable cmdlets obfuscation")
    fmt.Println("    --namespaces    enable namespace classes obfuscation")
    fmt.Println("    --backticks     enable backticks obfuscation")
    fmt.Println("    --case          enable uppercase/lowercase obfuscation")
    fmt.Println("    --pipes         enable pipes and pipelines obfuscation")
    fmt.Println("    --comments      remove and obfuscate comments")
    fmt.Println("    --indentation   add random indentation")
    fmt.Println("    --ips           obfuscate IP adddresses by converting them to hex format")
    fmt.Println()
    fmt.Println("  EXTRA:")
    fmt.Println("    -v, --verbose   enable verbose")
    fmt.Println("    -d, --debug     enable debug mode to check how obfuscation works")
    fmt.Println("    -h, --help      show help panel")
    fmt.Println("    --about         show information about how to use this tool")
    fmt.Println()
    fmt.Println("Examples:")
    fmt.Println("  vulkan -f script.ps1 -o output.ps1 --verbose")
    fmt.Println("  vulkan -f script.ps1 -o output.ps1 --all")
    fmt.Println("  vulkan -f script.ps1 -o output.ps1 --vars --cmdlets")
}

func showAboutPanel() {
    fmt.Println("Vulkan obfuscated Powershell code to prevent it from being detected by antivirus solutions. To do so, it uses regular expressions (to parse the data) and logical operators (to create semi-random data).")
    fmt.Println("This tool contains 3 different modes: safe, all and custom")
    fmt.Println("Safe mode (--safe) is enabled by default and it will perform most of the obfuscation techniques to grant the best safety and obfuscation at the same time. However, you can use --all to enable all obfuscation techniques (it should not break the script). Custom mode allows you to enable the best obfuscation techniques for your needs.")
}

func main() {
    rand.Seed(time.Now().UnixNano())

    // Print banner
    printASCII()

    // Parse command line arguments
    args := os.Args[1:]
    if len(args) == 0 {
        showHelpPanel()
        return
    }

    var inputFile, outputFile string
    var help, about, all, safe, verbose bool
    var customFlags = make(map[string]bool)

    // Simple argument parsing (for demo purposes)
    for i := 0; i < len(args); i++ {
        arg := args[i]
        switch arg {
        case "-h", "--help":
            help = true
        case "--about":
            about = true
        case "-f", "--file":
            if i+1 < len(args) {
                inputFile = args[i+1]
                i++
            }
        case "-o", "--output":
            if i+1 < len(args) {
                outputFile = args[i+1]
                i++
            }
        case "-a", "--all":
            all = true
        case "-s", "--safe":
            safe = true
        case "-v", "--verbose":
            verbose = true
        case "--vars":
            customFlags["vars"] = true
        case "--funcs":
            customFlags["funcs"] = true
        case "--cmdlets":
            customFlags["cmdlets"] = true
        case "--namespaces":
            customFlags["namespaces"] = true
        case "--backticks":
            customFlags["backticks"] = true
        case "--case":
            customFlags["case"] = true
        case "--pipes":
            customFlags["pipes"] = true
        case "--comments":
            customFlags["comments"] = true
        case "--indentation":
            customFlags["indentation"] = true
        case "--ips":
            customFlags["ips"] = true
        case "--special":
            customFlags["special"] = true
        }
    }

    // Handle help and about flags
    if help {
        showHelpPanel()
        return
    }

    if about {
        showAboutPanel()
        return
    }

    // Check required arguments
    if inputFile == "" {
        fmt.Println("[!] File parameter missing. See --help for help")
        return
    }

    if outputFile == "" {
        fmt.Println("[!] Output parameter missing. See --help for help")
        return
    }

    verboseMode = verbose

    // Determine mode
    if len(customFlags) > 0 {
        fmt.Println("[+] Using custom obfuscation techniques")
        caseObfs = customFlags["case"]
    } else if !all && !safe {
        fmt.Println("[+] Using safe obfuscation techniques")
        safeMode = true
        caseObfs = true
    } else if !all && safe {
        fmt.Println("[+] Using safe obfuscation techniques")
        safeMode = true
        caseObfs = true
    } else if all && !safe {
        fmt.Println("[+] Using all obfuscation techniques")
        allMode = true
        caseObfs = true
    } else if all && safe {
        fmt.Println("[+] Using all obfuscation techniques")
        allMode = true
        caseObfs = true
    }

    // Read input file
    fileData, err := os.ReadFile(inputFile)
    if err != nil {
        fmt.Printf("[!] Error reading file: %v\n", err)
        return
    }

    data := string(fileData)
    fmt.Printf("[+] File: %s\n", inputFile)

    currentTime := time.Now().Format("15:04:05")
    fmt.Printf("[*] Starting obfuscation process at %s\n", currentTime)

    // Perform obfuscation
    if safeMode {
        data = obfuscateSafe(data)
    } else if allMode {
        data = obfuscateAll(data)
    } else {
        if customFlags["comments"] {
            data = obfuscateComments(data)
        }
        if customFlags["vars"] {
            data = obfuscateVariables(data)
        }
        if customFlags["funcs"] {
            data = obfuscateFunctions(data)
        }
        if customFlags["cmdlets"] {
            data = obfuscateCmdlets(data)
        }
        if customFlags["namespaces"] {
            data = obfuscateNamespaces(data)
        }
        if customFlags["backticks"] {
            data = obfuscateBackticks(data)
        }
        if customFlags["pipes"] {
            data = obfuscatePipes(data)
        }
        if customFlags["indentation"] {
            data = obfuscateIndentation(data)
        }
        if customFlags["ips"] {
            data = obfuscateIPs(data)
        }
        if customFlags["special"] {
            data = obfuscateSpecialVars(data)
        }
    }

    // Write output file
    err = os.WriteFile(outputFile, []byte(data), 0644)
    if err != nil {
        fmt.Printf("[!] Error writing file: %v\n", err)
        return
    }

    fmt.Printf("\n[+] Obfuscated script written to %s\n", outputFile)
}
